function [evmInfo,eqSym,refSym] = hNRDownlinkEVM(waveConfig,rxWaveform,cfg)
%hNRDownlinkEVM EVM calculation
%   [EVMINFO,EQSYM,REFSYM] = hNRDownlinkEVM(WAVECONFIG,RXWAVEFORM,CFG)
%   Calculates the error vector magnitude (EVM) of a received waveform. EVM
%   is measured for physical data shared channel (PDSCH) and/or physical
%   downlink control channel (PDCCH). If cfg.EVM3GPP is true, EVM
%   measurement for PDSCH is done using the 3GPP specified EVM algorithm as
%   defined in TS 38.104, Annex B(FR1) / Annex C(FR2). EVM for PDCCH is
%   measured with cfg.EVM3GPP as false.
%
%   EVMINFO is a structure with fields:
%   PDSCH              - numBWPs-by-1 struct array of EVM statistics
%                        numBWPs is the number of configured bandwidth parts
%   PDCCH              - numBWPs-by-1 struct array of EVM statistics
%                        numBWPs is the number of configured bandwidth parts
%   The EVM statistics have these fields :
%      SubcarrierRMS   - RMS EVM per subcarrier
%                        (Column vector of N subcarriers)
%      SubcarrierPeak  - Peak EVM per subcarrier
%                        (Column vector of N subcarriers)
%      SymbolRMS       - RMS EVM per symbol
%                        (Column vector of S symbols)
%      SymbolPeak      - Peak EVM per symbol
%                        (Column vector of S symbols)
%      SlotRMS         - RMS EVM per slot
%                        (Column vector of L slots)
%      SlotPeak        - Peak EVM Per slot
%                        (Column vector of L slots)
%      EVMGrid         - Raw error vector for the selected window edge
%                        (N subcarriers-by-S symbols)
%      OverallEVM      - structure containing EVM statistics for the
%                        overall waveform. It contains these fields:
%         EV           - Raw error vector for the overall waveform
%                        (Array of q-by-n layers). q is the length of
%                        the error vector concatenated for the active
%                        slots in the waveform
%         RMS          - RMS EVM for the overall waveform
%                        (Scalar)
%         Peak         - Peak EVM for the overall waveform
%                        (Scalar)
%      BandwidthPartID - Index of the bandwidth part
%      AverageFO       - Estimated frequency estimate
%      AmpImbalance    - Estimated amplitude imbalance (dB)
%      PhImbalance     - Estimated phase imbalance (degrees)
%
%   EQSYM              - Output cell array of IQ constellations.
%                        (e-by-numBWPs) e is 1 when cfg.Evm3GPP is
%                        false and 2 otherwise. Each cell array element
%                        contains an array of q-by-n layers IQ
%                        constellations. q is a vector of all the IQs
%                        concatenated for the active slots in the waveform
%                        
%   REFSYM             - Output cell array of reference IQ constellations.
%                        (e-by-numBWPs) e is 1 when cfg.Evm3GPP is
%                        false and 2 otherwise. Each cell array element
%                        contains an array of q-by-n layers IQ
%                        constellations. q is the vector of all the IQs
%                        concatenated for the active slots in the waveform
%
%
%   WAVECONFIG         - Input object of type 'nrDLCarrierConfig'
%
%   RXWAVEFORM         - Time domain baseband IQ samples input. Timing of
%                        the waveform is assumed to be slot-wise aligned
%                        with sample level fine-tuning performed
%                        subsequently. The length of the waveform can be an
%                        arbitrary number of slots
%
%   CFG is a input structure with the fields:
%   Evm3GPP            - Enables or disables 3GPP method of EVM computation
%                        (Default value: false)
%   TargetRNTIs        - Contains the list of target RNTIs to decode. If
%                        not specified, the list is autogenerated as
%                        specified in the standard
%                        (Default value: empty)
%   PlotEVM            - Enables or disables plotting of EVM (per slot, per
%                        symbol, per subcarrier and overall EVM)
%                        (Default value: true)
%   DisplayEVM         - Enables or disables the display of
%                        EVM statistics on the command window 
%                        (Default value: true)
%   InitialNSlot       - Starting slot of the input waveform
%                        (Default value: 0)
%   SampleRate         - Waveform sample rate. If absent, the default
%                        waveform sample rate specified in WAVECONFIG is
%                        used for demodulation. It is specified as either a
%                        positive scalar or [].
%   PdschEnable        - Enables or disables EVM measurement of PDSCH
%                        configurations
%                        (Default value: true)
%   PdcchEnable        - Enables or disables EVM measurement of PDCCH
%                        configurations
%                        (Default value: true)
%   CorrectCoarseFO    - Enables or disables coarse frequency offset (FO)
%                        estimation and correction. If enabled, the
%                        waveform start slot should match InitialNSlot.
%                        (Default value: false)
%   CorrectFineFO      - Enables or disables fine FO estimation and
%                        correction
%                        (Default value: false)
%   TimeSyncEnable     - Enables or disables timing estimation
%                        (Default value: true)
%   UseWholeGrid       - Enables or disables the use of a reference grid,
%                        consisting of known data and demodulation
%                        reference signals (DM-RS) IQ samples for timing
%                        estimation purposes. Enable 'UseWholeGrid' when
%                        there are only few DM-RS symbols in the received
%                        waveform or when the timing synchronization is
%                        done over a short part of the frame, for example,
%                        just a slot
%                        (Default value: false)
%   IQImbalance        - Enables or disables I/Q imbalance estimation and
%                        correction
%                        (Default value: false)
%   ExcludeDC          - Enables or disables DC subcarrier from EVM
%                        processing
%                        (Default value: false)
%   DCOffset           - Enables or disables DC offset estimation and
%                        correction
%                        (Default value: false)

% Copyright 2019-2023 The MathWorks, Inc.

    narginchk(3,3);

    % Validate inputs
    validateInputs(waveConfig,cfg);

    if ~isfield(cfg,'Evm3GPP')
        evm3GPP = false;
    else
        evm3GPP = cfg.Evm3GPP;
    end
    if ~isfield(cfg,'TargetRNTIs')
        targetRNTIs = [];
    else
        targetRNTIs = cfg.TargetRNTIs;
    end
    if ~isfield(cfg,'PlotEVM')
        plotEVM = true;
    else
        plotEVM = cfg.PlotEVM;
    end
    if ~isfield(cfg,'DisplayEVM')
        displayEVM = true;
    else
        displayEVM = cfg.DisplayEVM;
    end
    if ~isfield(cfg,'InitialNSlot')
        initialNSlot = 0;
    else
        initialNSlot = cfg.InitialNSlot;
    end
    if ~isfield(cfg,'PdschEnable')
        pdschEnable = true;
    else
        pdschEnable = cfg.PdschEnable;
    end
    if ~isfield(cfg,'PdcchEnable')
        pdcchEnable = true;
    else
        pdcchEnable = cfg.PdcchEnable;
    end
    if ~isfield(cfg,'CorrectCoarseFO')
        correctCoarseFO = false;
    else
        correctCoarseFO = cfg.CorrectCoarseFO;
    end
    if ~isfield(cfg,'CorrectFineFO')
        correctFineFO = false;
    else
        correctFineFO = cfg.CorrectFineFO;
    end
    if ~isfield(cfg,'TimeSyncEnable')
        timeSyncEnable = true;
    else
        timeSyncEnable = cfg.TimeSyncEnable;
    end
    if ~isfield(cfg,'UseWholeGrid')
        useWholeGrid = false;
    else
        useWholeGrid = cfg.UseWholeGrid;
    end
    if ~isfield(cfg,'IQImbalance')
        iqImbalance = false;
    else
        iqImbalance = cfg.IQImbalance;
    end
    if ~isfield(cfg,'DCOffset')
        dcOffsetFlag = false;
    else
        dcOffsetFlag = cfg.DCOffset;
    end

    % Derive per-slot resources (waveformResources) used as reference for EVM calculation
    [~,winfo] = nrWaveformGenerator(waveConfig);
    waveformResources = winfo.WaveformResources;

    numBWPs = length(waveConfig.BandwidthParts);
    eqSym = cell(1+evm3GPP,numBWPs);                  % Equalized symbols for constellation plot, for each low/high EVM window location and BWP
    refSym = cell(1+evm3GPP,numBWPs);                 % Reference symbols for constellation plot, for each low/high EVM window location and BWP
    pdcchEqSym = cell(1,numBWPs);                     % PDCCH equalized symbols for each BWP
    pdcchRefSym = cell(1,numBWPs);                    % PDCCH reference symbols for each BWP
    evmInfo = [];                                     % EVM statistics

    % Store the received waveform for reuse in each BWP
    % Loop over each BWP
    rxWaveformOrig = rxWaveform;
    for bwpIdx = 1:numBWPs

        % Reset 'excludeDC' for each BWP
        if ~isfield(cfg,'ExcludeDC')
            excludeDC = false;
        else
            excludeDC = cfg.ExcludeDC;
        end

        % Display error messages for the below checks for pdschArray Ensure
        % modulation and number of layers is same across the valid RNTI set
        % At least one non-empty resource field should be present
        % pdschArray should have at least one non-empty DM-RS resources
        % At least one PDSCH Configuration should be enabled
        resourceEmptyCount = 0;
        dmrsEmptyCount = 0;
        pdschDisabledCount = 0;

        % Check validity of each BWP configuration
        invalidBWPConfigFlag = false;

        bwpCfg = waveConfig.BandwidthParts{bwpIdx};
        [pdschArray,~,carrier] = hListTargetPDSCHs(waveConfig,waveformResources,targetRNTIs,bwpIdx);
        
        % Extract PDCCH resources in this BWP
        pdcchWaveCfg = [];
        pdcchDefs = [waveConfig.PDCCH{:}];
        pdcchCfgLen = length(pdcchDefs);
        for n = 1:pdcchCfgLen
            if any(pdcchDefs(n).BandwidthPartID == waveConfig.BandwidthParts{bwpIdx}.BandwidthPartID)
                ri = waveformResources.PDCCH(n);
                ri.PDCCH = pdcchDefs(n);
                pdcchWaveCfg = [pdcchWaveCfg ri];
            end
        end

        % Skip PDCCH processing for empty or disabled PDCCH configurations
        if isempty(pdcchWaveCfg) || isempty(find([pdcchDefs(:).Enable],1)) || ~pdcchEnable
            pdcchCfgLen = 0;
        end
        
        pdschCfgLen = length(pdschArray);

        % knobs used to disable pdsch processing
        if ~pdschEnable
            pdschCfgLen = 0;
        end

        if isempty(pdschArray)
            invalidBWPConfigFlag = true;
        end

        % Check each PDSCH configuration for valid configurations
        for idx = 1:pdschCfgLen
            if idx > 1 && ~strcmp(pdschArray(idx-1).PDSCH.Modulation,pdschArray(idx).PDSCH.Modulation)
                error('All RNTIs must have the same modulation.');
            end
            if idx > 1 && (pdschArray(idx-1).PDSCH.NumLayers ~= pdschArray(idx).PDSCH.NumLayers)
                error('All RNTIs must have the same number of layers.');
            end
            if pdschArray(idx).PDSCH.NumLayers > 4
                error('More than 1 codewords not supported.')
            end
            if isempty(pdschArray(idx).Resources) || isempty(pdschArray(idx).PDSCH.PRBSet) || ...
                isempty(pdschArray(idx).PDSCH.SymbolAllocation) || pdschArray(idx).PDSCH.SymbolAllocation(2) == 0
                resourceEmptyCount = resourceEmptyCount + 1;
            end
            nonEmptyCount = 0;
            for rIdx = 1:length(pdschArray(idx).Resources)
                if ~isempty(pdschArray(idx).Resources(rIdx).DMRSSymbols)
                    nonEmptyCount = nonEmptyCount + 1;
                end
            end
            if nonEmptyCount == 0
                dmrsEmptyCount = dmrsEmptyCount + 1;
            end
            if ~pdschArray(idx).PDSCH.Enable
                pdschDisabledCount = pdschDisabledCount + 1;
            end
        end
        if resourceEmptyCount == pdschCfgLen && pdschEnable && ~isempty(pdschArray)
            warning('Input configuration does not contain adequate resources to proceed with EVM measurement');
            invalidBWPConfigFlag = true;
        end
        if dmrsEmptyCount == pdschCfgLen && pdschEnable && ~isempty(pdschArray)
            warning('Input configuration does not contain DM-RS resources to proceed with EVM measurement');
            invalidBWPConfigFlag = true;
        end
        if pdschDisabledCount == pdschCfgLen && pdschEnable && ~isempty(pdschArray)
            warning('Input configuration does not contain valid PDSCH resources to proceed with EVM measurement');
            invalidBWPConfigFlag = true;
        end

        % Skip PDSCHs in this BWP due to unexpected configuration
        if invalidBWPConfigFlag
            pdschCfgLen = 0;
            pdschArray = [];
        end

        % Obtain OFDM related info
        ofdmInfo = nrOFDMInfo(carrier);
        totalConfiguredSlots = waveConfig.NumSubframes*ofdmInfo.SlotsPerSubframe;
        initialNSlot = mod(initialNSlot,totalConfiguredSlots);
        carrier.NSlot = initialNSlot;
        L = ofdmInfo.SymbolsPerSlot;
        sampleRate = winfo.ResourceGrids(bwpIdx).Info.SampleRate;
        if ~isfield(cfg,'SampleRate') || isempty(cfg.SampleRate)
            rxWaveform = rxWaveformOrig;
        else
            rxWaveform = resample(rxWaveformOrig,sampleRate,cfg.SampleRate);
        end
        k0 = winfo.ResourceGrids(bwpIdx).Info.k0;
        scs = carrier.SubcarrierSpacing;
        ofdmInfo.SamplesPerSubframe = sampleRate/1000;

        % Generate a reference grid of length two frames for timing synchronization
        refGrid = hReferenceGrid(carrier,bwpCfg,pdschArray,ofdmInfo.SlotsPerFrame*2,'PDSCH');

        % Shift in frequency the waveform, taking into account the 'k0' for the current BWP
        t = (0:size(rxWaveform,1)-1).'/sampleRate;
        k0Offset = k0*scs*1e3;
        rxWaveformk0Shifted = rxWaveform.*exp(-1i*2*pi*k0Offset*t);

        % Estimate the coarse and integer FO
        % Correct the received waveform with these estimates
        foffsetEstCoarse = 0;
        integerCfoHz = 0;
        if correctCoarseFO && pdschCfgLen
            foffsetEstCoarse = hNRFrequencyOffset('coarseFO',carrier,rxWaveformk0Shifted,sampleRate);
            rxWaveformk0Shifted = hNRFrequencyOffset('FOCorrect',rxWaveformk0Shifted,sampleRate,foffsetEstCoarse);
            integerCfoHz = hNRFrequencyOffset('integerFO',carrier,rxWaveformk0Shifted,refGrid,sampleRate,waveConfig.CarrierFrequency+k0Offset);
            rxWaveformk0Shifted = hNRFrequencyOffset('FOCorrect',rxWaveformk0Shifted,sampleRate,integerCfoHz);
        end

        % Estimate and correct the I/Q imbalance for the received waveform
        ampImbEst = 0;
        phImbEst = 0;
        if iqImbalance

            dcOffset1 = 0;
            if dcOffsetFlag
                % Remove large DC offset before estimation of IQ imbalance
                dcOffset1 = mean(rxWaveformk0Shifted,'all');
            end
            rxWaveformk0Shifted = rxWaveformk0Shifted-dcOffset1;
            [rxWaveformk0Shifted,ampImbEst,phImbEst] = hNRIQImbalance(rxWaveformk0Shifted);

            % Add the estimated DC Offset back to the waveform
            rxWaveformk0Shifted = rxWaveformk0Shifted+dcOffset1;
        end

        % Time synchronization of input waveform
        offset = 0;
        if timeSyncEnable

            % Ensure large DC offsets are removed before calling
            % nrTimingEstimate
            dcOffset1 = 0;

            if dcOffsetFlag
                dcOffset1 = mean(rxWaveformk0Shifted,'all');
            end

            % If enabled, use a grid of known data and DM-RS IQ samples for
            % timing estimation
            if useWholeGrid
                refGrid = winfo.ResourceGrids(bwpIdx).ResourceGridInCarrier;
                refGrid(:,1:ofdmInfo.SymbolsPerSlot*carrier.NSlot,:) = [];
            end
            if ~isempty(refGrid)
                offset = nrTimingEstimate(carrier,rxWaveformk0Shifted-dcOffset1,refGrid,...
                    'SampleRate',sampleRate,'CarrierFrequency',waveConfig.CarrierFrequency+k0Offset);
            end
        end
        rxWaveform = rxWaveformk0Shifted(1+offset:end,:);

        % Get OFDM information for the given sample rate
        opts.cyclicPrefix = carrier.CyclicPrefix;
        opts.SampleRate = sampleRate;
        opts.NFFT = [];
        opts.CarrierFrequency = waveConfig.CarrierFrequency;
        info = nr5g.internal.OFDMInfo(carrier,opts);

        % Obtain the length of the first symbol
        temp = [winfo.ResourceGrids(:)];
        bIdx = find([temp.BandwidthPartID] == waveConfig.BandwidthParts{bwpIdx}.BandwidthPartID);
        firstSymbLen = winfo.ResourceGrids(bIdx).Info.SymbolLengths(1);
        r = info.Resampling;
        if (any([r.L r.M]~=1))
            firstSymbLen = ceil(firstSymbLen * r.L / r.M);
        end
        T = size(rxWaveform,1);
        if T < firstSymbLen
            %Skip this Bandwidth part if the input waveform is less than a
            %symbol long
            continue;
        end

        % Calculate number of slots and frames for the given
        % sampleRate
        gridSize = size(nrOFDMDemodulate(carrier,rxWaveform,'SampleRate',sampleRate));
        nSlots = floor(gridSize(2)/L);
        nFrames = floor(nSlots/(10*ofdmInfo.SlotsPerSubframe));

        % When the input waveform has more slots than
        % waveConfig.NumSubframes, regenerate pdsch, pdcch reference
        % resources and carrier with the correct number of slots
        % waveformPeriod takes into account the number of slots as
        % configured by waveConfig.NumSubframes. It is used to detect
        % waveform repetition and regenerate the waveform configuration
        % resources. 
        waveformPeriod = inf;
        if nSlots > waveConfig.NumSubframes*ofdmInfo.SlotsPerSubframe && ~invalidBWPConfigFlag

            waveformPeriod = waveConfig.NumSubframes*ofdmInfo.SlotsPerSubframe;
            waveformResources = winfo.WaveformResources;

            % Regenerate pdsch and pdcch configuration resources taking
            % into account number of waveform repetitions and period
            waveformResources = waveformResourcesRepeat(waveformResources,waveformPeriod,nSlots+initialNSlot);

            [pdschArray,~,carrier] = hListTargetPDSCHs(waveConfig,waveformResources,targetRNTIs,bwpIdx);
            carrier.NSlot = initialNSlot;

            % Extract PDCCH resources
            pdcchWaveCfg = [];
            pdcchDefs = [waveConfig.PDCCH{:}];
            for n = 1:pdcchCfgLen
                if any(pdcchDefs(n).BandwidthPartID == waveConfig.BandwidthParts{bwpIdx}.BandwidthPartID)
                    ri = waveformResources.PDCCH(n);
                    ri.PDCCH = pdcchDefs(n);
                    pdcchWaveCfg = [pdcchWaveCfg ri];
                end
            end
        end

        if nSlots == 0
            warning('No scheduled slots found for EVM processing');
            pdschCfgLen = 0;
            pdcchCfgLen = 0;
        end

        % Generate a reference grid, refGrid, for slots corresponding to
        % the length of the input waveform. This grid contains only the
        % DM-RS and is primarily used for channel estimation. 
        refGrid = hReferenceGrid(carrier,bwpCfg,pdschArray,nSlots,'PDSCH',waveformPeriod);

        if dcOffsetFlag && ~isempty(pdschArray)

            % Locate the first valid PDSCH and use it for DMRS location
            % selection
            for pIdx = 1:pdschCfgLen
                if ~isempty(pdschArray(pIdx).Resources(1).DMRSSymbolSet)
                   loc = pIdx;
                   break;
                end
            end
            firstDmrsLocInSlot = pdschArray(loc).Resources(1).DMRSSymbolSet(1)+1;
            [~,cdmLengths] = extractPdschCfg(pdschArray);

            % Force a coarse FO estimation and correction when only fine
            % FO estimation is enabled.
            if ~correctCoarseFO && correctFineFO
                foffsetEstCoarse = hNRFrequencyOffset('coarseFO',carrier,rxWaveform,sampleRate);
                rxWaveform = hNRFrequencyOffset('FOCorrect',rxWaveform,sampleRate,foffsetEstCoarse);
            end
            dcOffset = hNRDCOffset(carrier,waveConfig,rxWaveform,refGrid,...
                cdmLengths,firstDmrsLocInSlot,sampleRate,bwpIdx);
            rxWaveform = rxWaveform-dcOffset;
        end

        % Slot allocation of the PDSCH configurations may overlap with each
        % other. Extract unique allocated slots
        activeSlots = [];
        for pIdx = 1:pdschCfgLen
            if ~isempty(pdschArray(pIdx).Resources)
                activeSlots = [activeSlots pdschArray(pIdx).Resources.NSlot]; %#ok<*AGROW>
            end
        end
        if ~isempty(activeSlots)
            activeSlots = unique(activeSlots);
        end

        % Number of FFT Locations in each CP, based on EVM mode (Standard / 3GPP)
        nEVMWindowLocations = 1;
        if evm3GPP
            nEVMWindowLocations = 2;
        end

        % Resize refGrid based on BWP dimensions
        bwpStart = bwpCfg.NStartBWP-carrier.NStartGrid;
        if ~isempty(refGrid)
            refGrid = refGrid(12*bwpStart+1:12*(bwpStart+bwpCfg.NSizeBWP),:,:);
        end

        % Declare storage variables
        refSlotGrid = zeros(size(refGrid,1),nSlots*L,size(refGrid,3),nEVMWindowLocations);   % 4-D Grid of reference IQs
        eqSlotGrid = refSlotGrid;                                                            % 4-D Grid of equalized IQs
        frameEVM = repmat(hRawEVM([]), 1, max(nFrames,1));                                   % Per-frame EVM

        % Restrict CP length as per TS 38.104, Annex B.5.1 (FR1) / Annex C.5.1 (FR2)
        cpLength = double(ofdmInfo.CyclicPrefixLengths(2));

        % Populate pdschObj of type 'nrPDSCHConfig'. It is to be used for
        % Common Phase error (CPE) estimation and decoding PDSCH
        [pdschObj,cdmLengths] = extractPdschCfg(pdschArray);
        for idx = 1:pdschCfgLen
            pdschObj{idx}.NStartBWP = waveConfig.BandwidthParts{bwpIdx}.NStartBWP;
            pdschObj{idx}.NSizeBWP  = waveConfig.BandwidthParts{bwpIdx}.NSizeBWP;
            if isempty(pdschObj{idx}.NID)
                pdschObj{idx}.NID = carrier.NCellID;
            end
        end

        % If the waveform contains an encoded transport block, generate
        % reference parameters needed for decoding and re-encoding. The
        % re-encoded IQ samples are used as a reference for EVM calculation.
        pdschEncodingOn = false;
        for pIdx = 1:length(waveConfig.PDSCH)
            if waveConfig.PDSCH{pIdx}.Coding
                pdschEncodingOn = true;
                break;
            end
        end

        % When evm3GPP is true, two EVM window locations and two CP fractions
        % are selected for 3GPP EVM for OFDM demodulation. If false, a single
        % EVM window location is used, which is centred in the middle of the CP
        if evm3GPP
            W = getEVMWindow(carrier,waveConfig.FrequencyRange,waveConfig.ChannelBandwidth,ofdmInfo.Nfft);
            nEVMWindowLocations = 2;

            if (mod(W,2)==0)
                alpha = 1;
            else
                alpha = 0;
            end

             % Estimate deltaC centered on the CP
            deltaC = ceil(cpLength/2);
            cpFraction = [(deltaC + alpha - floor(W/2))/cpLength; (deltaC + floor(W/2))/cpLength];
        else
            nEVMWindowLocations = 1;
            cpFraction = 0.5;      % Use default value
        end

        % When correctFineFO is enabled, estimate FO for each valid slot
        % and store the averaged result in averageFO
        averageFO = foffsetEstCoarse+integerCfoHz;
        if correctFineFO && pdschEnable && pdschCfgLen
            [rxWaveform,averageFineFO] = hNRFrequencyOffset('fineFO',carrier,bwpCfg,rxWaveform,refGrid,[],...
                                      cdmLengths,sampleRate,activeSlots,waveConfig.CarrierFrequency+k0Offset);
            averageFO = averageFO + averageFineFO;
        end

        % Demodulate the waveform
        carrier.NSlot = initialNSlot;
        rxGridLow = nrOFDMDemodulate(carrier, rxWaveform, 'CyclicPrefixFraction',cpFraction(1),'SampleRate',sampleRate,...
                                                                            'CarrierFrequency',waveConfig.CarrierFrequency + k0Offset);
        if nEVMWindowLocations == 2
            rxGridHigh = nrOFDMDemodulate(carrier, rxWaveform, 'CyclicPrefixFraction',cpFraction(2),'SampleRate',sampleRate,...
                                                                               'CarrierFrequency',waveConfig.CarrierFrequency + k0Offset);
        end

         % Work only on the relevant BWP in the waveform to simplify indexing
         rxGridLow = rxGridLow(12*bwpStart+1:12*(bwpStart+bwpCfg.NSizeBWP),:,:);
         if evm3GPP
             rxGridHigh = rxGridHigh(12*bwpStart+1:12*(bwpStart+bwpCfg.NSizeBWP),:,:);
         end

         % Number of subcarriers in BWP
         numSCs = size(rxGridLow,1);

         % Locate DC for this carrier taking into account k0.
         % 'dcIndCarrier' is in 1-based notation.
         dcIndCarrier = (carrier.NSizeGrid*12)/2+1-k0;

         % Locate the DC subcarrier location for this bandwidth part
         % Adjust DC location based on BWP start
         dcInd = dcIndCarrier - bwpStart*12;

         % Disable DC exclusion if DC location is outside this BWP
         if ((dcInd < 1 || dcInd > numSCs) && excludeDC == true)
             excludeDC = false;
         end

         if excludeDC

             % Exclude DC from received waveform and refGrid
             rxGridLow(dcInd,:,:) = 0;
             refGrid(dcInd,:,:) = 0;
             if size(rxGridLow,3) > 1

                 % For number of layers > 1, exclude up to 6 subcarriers in refGrid,
                 % on either side of DC, account for allocation edges in this.
                 % This is needed to avoid channel estimates distortion (due
                 % to exclusion of the DC reference from 'refGrid')
                 dcIndLow = dcInd-5;
                 dcIndHigh = dcInd+6;
                 if dcIndLow < 1
                     dcIndLow = 1;
                 end
                 if dcIndHigh > numSCs
                     dcIndHigh = numSCs;
                 end
                 refGrid(dcIndLow:dcIndHigh,:) = 0;
             end
         end

         if pdschCfgLen
             rxGrids = cell(1,1+evm3GPP);
             rxGrids{1} = rxGridLow;
             if evm3GPP
                 rxGrids{2} = rxGridHigh;
             end
             [HestLow,HestHigh] = hChannelEstEVM(rxGrids,refGrid,cdmLengths,L,true);
         else
             HestLow = [];
             HestHigh = [];
         end

        % PDSCH REs may not always be present on the same set of RBs as DM-RS.
        % For each such slot, extrapolate the channel coefficients to span the
        % location of these PDSCH allocation regions

        % Ensure slot has channel coefficients for the corresponding PDSCH
        % allocation
        if pdschCfgLen
            for slotIdx = 1:nSlots
                symIdx = (slotIdx-1)*L+1:slotIdx*L;
                symIdx(symIdx>size(rxGridLow, 2)) = [];

                % Locate RBs where channel coefficients are present
                [row ,~]= find(HestLow(:,symIdx));
                row = unique(row);
                HestRb = unique(floor((row-1)/12));
                rxRb = [];
                for idx = 1:length(pdschArray)
                    if any(activeSlots == (slotIdx-1+initialNSlot))
                        rxRb = [rxRb pdschArray(idx).PDSCH.PRBSet];
                    end
                end

                % Set extrapolateHest to true if allocated RB list does not match
                % list of RBs containing channel coefficients
                extrapolateHest = false;
                for rbIdx = 1:length(rxRb)
                    if ~any(HestRb == rxRb(rbIdx))
                        extrapolateHest = true;
                        break;
                    end
                end

                % Process only for slots where PDSCH RBs do not contain channel
                % estimates. Using the 'nearest' interpolation method, extrapolate
                % the channel coefficients over the slot span. This method ensures
                % the same channel coefficient is extrapolated over the neighboring
                % frequency region. The first entry in the pdschArray is sufficient
                % for this purpose
                if extrapolateHest && ~isempty(HestRb)
                    firstDmrsLocInSlot = pdschArray(1).PDSCH.DMRS.DMRSSubcarrierLocations(1)+1;

                    R = size(HestLow,3);
                    P = size(HestLow,4);
                    for p = 1:P
                        for r = 1:R
                            H_tmp = HestLow(:,symIdx(firstDmrsLocInSlot),r,p);
                            if sum(abs(H_tmp)) == 0
                                interpEqCoeff = 1e-16.*ones(size(H_tmp,1),1);
                            else
                                interpEqCoeff = interp1(find(H_tmp~=0),H_tmp(H_tmp~=0),(1:numSCs).','nearest','extrap');
                            end
                            interpEqCoeff = repmat(interpEqCoeff,1,L);
                            HestLow(:,symIdx,r,p) = interpEqCoeff;
                        end
                    end
                end
            end
        end

        % In case of non-3GPP case, only a single EVM grid is used.
        % Compute the DL EVM for each active/valid DL slot, store the results
        % in a cell-array for later processing. Skip slots which are not DL.
        slotRange = activeSlots(activeSlots < (initialNSlot+nSlots));
        slotRange = slotRange(slotRange >= initialNSlot);
        if isempty(slotRange) && pdschEnable && ~isempty(pdschArray)
            slotRange = [];

            % display warning only if the waveform is more than a subframe long 
            if nSlots > ofdmInfo.SlotsPerSubframe
                warning('No scheduled slots found for EVM processing');
            end
            pdschCfgLen = 0;
        end

        % Concatenate rxGridLow, rxGridHigh, HestLow and HestLow for
        % further processing
        rxGrids = cell(1,1+evm3GPP);
        hest  = cell(1,1+evm3GPP);
        rxGrids{1} = rxGridLow;
        hest{1} = HestLow;
        if evm3GPP
            rxGrids{2} = rxGridHigh;
            hest{2} = HestHigh;
        end

        if pdschCfgLen
            % Skip control symbols if label is not empty, is a test model
            % or an FRC and extrapolateHest is false
            skipCtrlSymbols = ~isempty(waveConfig.Label) && ~extrapolateHest && ...
                contains(waveConfig.Label,["NR-FR", "DL-FRC"],'IgnoreCase',true);

            % Set skipCtrlSymbols to false if any of the PDSCH
            % configurations has a symbol allocation starting with 0 or 1
            if skipCtrlSymbols
                for idx = 1:length(pdschArray)
                    if pdschArray(idx).PDSCH.SymbolAllocation(1) < 2
                        skipCtrlSymbols = false;
                    end
                end
            end
            [eqSlotGrid,refSlotGrid,~,eqSym(:,bwpIdx),refSym(:,bwpIdx)] = hDecodeSlots(carrier,rxGrids,hest,...
                pdschArray,pdschObj,skipCtrlSymbols,pdschEncodingOn,waveformPeriod);

            if excludeDC

                % Exclude DC subcarrier symbols in eqSym, refSym,
                % eqSlotGrid & refSlotGrid
                d = find(eqSym{1,bwpIdx} == 0);
                eqSym{1,bwpIdx}(d) = [];
                refSym{1,bwpIdx}(d) = [];
                if evm3GPP
                    eqSlotGrid(dcInd,:,:,:) = 0;
                    refSlotGrid(dcInd,:,:,:) = 0;
                    d = find(eqSym{2,bwpIdx} == 0);
                    eqSym{2,bwpIdx}(d) = [];
                    refSym{2,bwpIdx}(d) = [];
                end
            end
        end

        % Loop for each PDCCH configuration in this BWP
        pdcchEqSlotGrid = [];
        pdcchRefSlotGrid = [];
        for pdcchCfgIdx = 1:size(pdcchWaveCfg,2)
            % Store the current PDCCH
            currentPdcchCfg = pdcchWaveCfg(pdcchCfgIdx);
            pdcchSlotRange = [];
            if currentPdcchCfg.PDCCH.Enable

                % Generate a reference grid, refGrid, for slots corresponding to
                % the length of the input waveform. This grid contains only the
                % DM-RS and is primarily used for channel estimation.
                refGrid = hReferenceGrid(carrier,bwpCfg,currentPdcchCfg,nSlots,'PDCCH',waveformPeriod);

                % Slot allocation list for the PDCCH configuration
                activeSlots = [currentPdcchCfg.Resources.NSlot];

                % Resize refGrid based on BWP dimensions
                refGrid = refGrid(12*bwpStart+1:12*(bwpStart+bwpCfg.NSizeBWP),:,:);

                % Demodulate the waveform
                pdcchRxGrid = nrOFDMDemodulate(carrier,rxWaveform,'SampleRate',sampleRate,'CarrierFrequency',waveConfig.CarrierFrequency + k0Offset);
                
                % Work only on the relevant BWP in the waveform to simplify indexing
                pdcchRxGrid = pdcchRxGrid(12*bwpStart+1:12*(bwpStart+bwpCfg.NSizeBWP),:,:);

                % Compute the PDCCH EVM for each active/valid PDCCH slots, store the results
                % in a cell-array for later processing. Skip slots which are not allocated
                pdcchSlotRange = activeSlots(activeSlots < initialNSlot+nSlots);
                pdcchSlotRange = pdcchSlotRange(pdcchSlotRange >= initialNSlot);
                if isempty(pdcchSlotRange)
                    pdcchSlotRange = [];
                    plotEVM = false;

                    % display warning only if the waveform is more than a subframe long
                    if nSlots > ofdmInfo.SlotsPerSubframe
                        warning('No scheduled slots found for EVM processing');
                    end
                end

                % Obtain channel estimates
                pdcchHest = hChannelEstEVM({pdcchRxGrid},refGrid,currentPdcchCfg.CDMLengths,L,false);

                % Decode the slots with PDCCH
                [eq,ref,~,tmpEqSym,tmpRefSym] = hDecodeSlots(carrier,{pdcchRxGrid},{pdcchHest},...
                    currentPdcchCfg,[],waveformPeriod);
                if isempty(pdcchEqSlotGrid) ||  sum(size(eq) - size(pdcchEqSlotGrid)) 
                   pdcchEqSlotGrid = zeros(size(eq));
                   pdcchRefSlotGrid = pdcchEqSlotGrid;
                end
                pdcchEqSlotGrid = pdcchEqSlotGrid + eq;
                pdcchRefSlotGrid = pdcchRefSlotGrid + ref;
                pdcchEqSym{:,bwpIdx} = [pdcchEqSym{:,bwpIdx} ; tmpEqSym{:}];
                pdcchRefSym{:,bwpIdx} = [pdcchRefSym{:,bwpIdx} ; tmpRefSym{:}];
            end
        end
        if excludeDC

            % Exclude DC subcarrier symbols in pdcchEqSym, pdcchRefSym,
            % pdcchEqSlotGrid & refSlotGrid
            d = find(pdcchEqSym{1,bwpIdx} == 0);
            if ~isempty(d)
                pdcchEqSym{1,bwpIdx}(d) = [];
                pdcchRefSym{1,bwpIdx}(d) = [];
            end
            if evm3GPP && ~isempty(d)
                pdcchEqSlotGrid(dcInd,:,:,:) = 0;
                pdcchRefSlotGrid(dcInd,:,:,:) = 0;
                d = find(pdcchEqSym{2,bwpIdx} == 0);
                pdcchEqSym{2,bwpIdx}(d) = [];
                pdcchRefSym{2,bwpIdx}(d) = [];
            end
        end

        if isempty(evmInfo)
            evmInfo.PDSCH = [];
            evmInfo.PDCCH = [];
        end
        if pdschCfgLen
            tmp = hEVM(carrier,eqSlotGrid,refSlotGrid);
            evm = tmp.EVM;
            % Remove EVM field as it not part of the output
            if ~isempty(tmp)
                tmp = rmfield(tmp,'EVM');
            end
            tmp.BandwidthPartID = waveConfig.BandwidthParts{bwpIdx}.BandwidthPartID;
            tmp.AverageFO = averageFO;
            tmp.AmpImbalance = ampImbEst;
            tmp.PhImbalance = phImbEst;
            evmInfo.PDSCH = [evmInfo.PDSCH; tmp];
        end

        % Evaluate detailed EVM statistics for a grid of PDCCH equalized and reference slot
        if pdcchCfgLen
            tmp  = hEVM(carrier,pdcchEqSlotGrid,pdcchRefSlotGrid);
            evmPdcch = tmp.EVM;
            if ~isempty(tmp)
                tmp = rmfield(tmp,'EVM');
            end
            tmp.BandwidthPartID = waveConfig.BandwidthParts{bwpIdx}.BandwidthPartID;
            tmp.AverageFO = averageFO;
            tmp.AmpImbalance = ampImbEst;
            tmp.PhImbalance = phImbEst;
            evmInfo.PDCCH = [evmInfo.PDCCH; tmp];
        end

        % Display per slot, and per EVM edge EVM statistics
        if displayEVM && (pdschCfgLen || pdcchCfgLen)
            disp("EVM stats for BWP idx : " + num2str(bwpIdx));
        end
        for slotIdx  = slotRange
            for e = 1:nEVMWindowLocations
                if (e == 1)
                    edge = 'Low edge ';
                    if nEVMWindowLocations == 1
                        edge = '';              % Print only single EVM per slot
                    end
                else
                    edge = 'High edge ';
                end
                if displayEVM
                    fprintf('%sPDSCH RMS EVM, Peak EVM, slot %d: %0.3f %0.3f%%\n',edge,slotIdx,evm(e, slotIdx+1).RMS*100,evm(e, slotIdx+1).Peak*100);
                end
            end
        end
        if displayEVM && pdcchCfgLen
            for slotIdx = pdcchSlotRange
                fprintf('PDCCH RMS EVM, Peak EVM, slot %d: %0.3f %0.3f%%\n',slotIdx,evmPdcch(1, slotIdx+1).RMS*100,evmPdcch(1, slotIdx+1).Peak*100);
            end
        end

       printFrameAvg = 1;      % Ensures only fully occupied frames are printed
        % After we've filled a frame or if we're at the end of a signal
        % shorter than a frame, do EVM averaging
        if (nFrames == 0)
            nFrames = 1;     % Below loop needs to run at least once
            printFrameAvg = 0; % Don't print low/high EVM as we don't have sufficient slots to fill up a frame
        end

        % 1-based indexing for accessing evm
        % Limit frame-averaging to complete frames only
        slotRange = slotRange+1;
        slotRange = slotRange(slotRange <= (nFrames*10*ofdmInfo.SlotsPerSubframe));

        % loop through each frame, selecting the frames with higher RMS( when
        % measuring 3GPP EVM)
        if pdschCfgLen
            for frameIdx = 0:nFrames-1
                % Pick slots in this frame
                L = 10*ofdmInfo.SlotsPerSubframe;
                slotsInFrame = slotRange((slotRange > (frameIdx)*L) & (slotRange <= (frameIdx+1)*L));
                frameLowEVM = hRawEVM(cat(1,evm(1,slotsInFrame).EV));
                frameEVM(frameIdx+1) = frameLowEVM;
                if evm3GPP
                    frameHighEVM = hRawEVM(cat(1,evm(2,slotsInFrame).EV));
                    if frameHighEVM.RMS > frameLowEVM.RMS
                        frameEVM(frameIdx+1) = frameHighEVM;
                    end
                end
                if printFrameAvg && displayEVM
                    if evm3GPP
                        fprintf('Averaged low edge RMS EVM, frame %d: %0.3f%%\n',frameIdx,frameLowEVM.RMS*100);
                        fprintf('Averaged high edge RMS EVM, frame %d: %0.3f%%\n',frameIdx,frameHighEVM.RMS*100);
                    end
                    fprintf('Averaged RMS EVM frame %d: %0.3f%%\n',frameIdx,frameEVM(frameIdx+1).RMS*100);
                end
            end
        end

        if plotEVM
            % For each valid slot, update the plot (symbol,SC,slot,grid-wise)
            if pdschCfgLen
                pIdx = find([evmInfo.PDSCH(:).BandwidthPartID] == bwpCfg.BandwidthPartID);
                hEVMPlots(evmInfo.PDSCH(pIdx),eqSym{1,bwpIdx},refSym{1,bwpIdx},'PDSCH');
            end
            if pdcchCfgLen
                pIdx = find([evmInfo.PDCCH(:).BandwidthPartID] == bwpCfg.BandwidthPartID);
                hEVMPlots(evmInfo.PDCCH(pIdx),pdcchEqSym{1,bwpIdx},pdcchRefSym{1,bwpIdx},'PDCCH');
            end
        end

        if displayEVM
            if pdschCfgLen
                pIdx = find([evmInfo.PDSCH(:).BandwidthPartID] == bwpCfg.BandwidthPartID);
                fprintf('Averaged overall PDSCH RMS EVM: %0.3f%%\n', evmInfo.PDSCH(pIdx).OverallEVM.RMS*100);
                disp("Overall PDSCH Peak EVM = " + string((evmInfo.PDSCH(pIdx).OverallEVM.Peak)*100) + "%");
            end
            if pdcchCfgLen
                pIdx = find([evmInfo.PDCCH(:).BandwidthPartID] == bwpCfg.BandwidthPartID);
                fprintf('Averaged overall PDCCH RMS EVM: %0.3f%%\n', evmInfo.PDCCH(pIdx).OverallEVM.RMS*100);
                disp("Overall PDCCH Peak EVM = " + string((evmInfo.PDCCH(pIdx).OverallEVM.Peak)*100) + "%");
            end
        end
    end
end

function W = getEVMWindow(carrier,frequencyRange,channelBandwidth,nFFT)
%   W = getEVMWindow(CARRIER,FREQUENCYRANGE,CHANNELBANDWIDTH,NFFT) is the
%   error vector magnitude window length, as mentioned in TS 38.104, Section
%   B.5.2 < FR1 /FR2 >. W is defined for a given combination of subcarrier
%   spacing, channel bandwidth/fft length, frequency range and CP type. W
%   is subsequently used as an intermediate value to decide the CP Fraction
%   for OFDM demodulation

    scsFR1 = [15 30 60];
    scsFR2 = [60 120];
    % BW MHz        5  10 15 20  25  30  40  50  60  70  80  90  100
    nfftFR1 = [256 384 512 768 1024 1536 2048 3072  4096];
    WsFR1   = [NaN NaN  14 NaN   28   44   58  108   144;      % NormalCp, 15kHz
                 8 NaN  14  22   28   54   72  130   172;      % NormalCp, 30kHz
                 8  11  14  26   36   64   86  NaN   NaN;      % NormalCp, 60kHz
                54  80 106 164  220  340  454  NaN   NaN];     % ExtendedCp, 60kHz

    % BW MHz        50 100 200 400
    nfftFR2 = [512 1024 2048 4096];
    WsFR2        = [NaN  36  72  144;                           % NormalCP, 60kHz
                    18   36  72  144;                          % NormalCP, 120kHz
                   NaN  220  440 880];                         % ExtendedCP, 60kHz
    W = []; %#ok<NASGU>
    if (strcmpi(frequencyRange,'FR1'))
        rowIdx = find(carrier.SubcarrierSpacing == scsFR1) + double(strcmpi(carrier.CyclicPrefix,'extended'));
        W = WsFR1(rowIdx,nFFT == nfftFR1);
        if channelBandwidth == 25
            if nFFT == 512 && carrier.SubcarrierSpacing == 60
                if strcmpi(carrier.CyclicPrefix,'extended')
                    W = 110;
                else
                    W = 18;
                end
            elseif nFFT == 1024 && carrier.SubcarrierSpacing == 30
                W = 36;
            elseif nFFT == 2048 && carrier.SubcarrierSpacing == 15
                W = 72;
            end
        end
    else
        rowIdx = find(carrier.SubcarrierSpacing == scsFR2) + double(strcmpi(carrier.CyclicPrefix,'extended'))*2;
        W = WsFR2(rowIdx,nFFT == nfftFR2);
    end
    % Filter out invalid combinations
    if anynan(W) || isempty(W)
        error('Invalid FFT/SCS/BW combination');
    end
end

function [pdschObj,cdmLengths] = extractPdschCfg(pdschWaveCfg)
    % Extract relevant parameters from waveform generator PDSCH struct to build an obj of type 'nrPDSCHConfig' 
    % Set PDSCH parameters
    pdschObj = {};
    cdmLengths = [];
    for idx = 1:length(pdschWaveCfg)
        pdschObj{idx} = nrPDSCHConfig;
        pdsch = pdschWaveCfg(idx).PDSCH;
        pdschObj{idx}.PRBSet = pdsch.PRBSet;
        pdschObj{idx}.SymbolAllocation     = pdsch.SymbolAllocation;
        pdschObj{idx}.Modulation           = pdsch.Modulation;
        pdschObj{idx}.NumLayers            = pdsch.NumLayers;
        pdschObj{idx}.MappingType          = pdsch.MappingType;
        pdschObj{idx}.RNTI                 = pdsch.RNTI;
        pdschObj{idx}.NID                  = pdsch.NID;
        pdschObj{idx}.VRBToPRBInterleaving = pdsch.VRBToPRBInterleaving;
        pdschObj{idx}.VRBBundleSize        = pdsch.VRBBundleSize;

        for idx2 = 1:length(pdsch.ReservedPRB)
            pdschObj{idx}.ReservedPRB{idx2} = nrPDSCHReservedConfig;     
            pdschObj{idx}.ReservedPRB{idx2}.PRBSet    = pdsch.ReservedPRB{idx2}.PRBSet;
            pdschObj{idx}.ReservedPRB{idx2}.SymbolSet = pdsch.ReservedPRB{idx2}.SymbolSet;
            pdschObj{idx}.ReservedPRB{idx2}.Period    = pdsch.ReservedPRB{idx2}.Period;
        end

        % Set DM-RS parameters
        pdschObj{idx}.DMRS = pdsch.DMRS;

        % Set PT-RS parameters
        pdschObj{idx}.EnablePTRS = pdsch.EnablePTRS;
        pdschObj{idx}.PTRS = pdsch.PTRS;

        if pdschWaveCfg(idx).PDSCH.Enable && sum(pdschWaveCfg(idx).CDMLengths)
            cdmLengths = pdschWaveCfg(idx).CDMLengths;
        end
    end
end

function validateInputs(waveconfig,evmCfg)
%   validateInputs(WAVECONFIG,CFG)
%   validates the waveform configuration WAVECONFIG and evm configuration
%   EVMCFG used for EVM measurement.

    fcnName = 'hNRDownlinkEVM';

    % Validate 'waveconfig'
    if ~isa(waveconfig,'nrDLCarrierConfig')
        error('Input waveform configuration must be of type: nrDLCarrierConfig');
    end
    % Validate 'evmCfg'
    if isfield(evmCfg,'Evm3GPP')
        validateattributes(evmCfg.Evm3GPP,{'logical','double'},{'nonempty'},fcnName,'Evm3GPP');
    end
    if isfield(evmCfg,'TargetRNTIs') && ~isempty(evmCfg.TargetRNTIs)
        validateattributes(evmCfg.TargetRNTIs,{'numeric'},{'vector'},fcnName,'TargetRNTIs');
    end
    if isfield(evmCfg,'PlotEVM')
        validateattributes(evmCfg.PlotEVM,{'logical','double'},{'nonempty'},fcnName,'PlotEVM');
    end
    if isfield(evmCfg,'DisplayEVM')
        validateattributes(evmCfg.DisplayEVM,{'logical','double'},{'nonempty'},fcnName,'DisplayEVM');
    end
    if isfield(evmCfg,'InitialNSlot')
        validateattributes(evmCfg.InitialNSlot,{'numeric'},{'nonnegative'},fcnName,'InitialNSlot');
    end
    if isfield(evmCfg,'SampleRate')
        validateattributes(evmCfg.SampleRate,{'numeric'},{'integer','positive'},fcnName,'SampleRate');
    end
    if isfield(evmCfg,'PdschEnable')
        validateattributes(evmCfg.PdschEnable,{'logical','double'},{'nonempty'},fcnName,'PdschEnable');
    end
    if isfield(evmCfg,'PdcchEnable')
        validateattributes(evmCfg.PdcchEnable,{'logical','double'},{'nonempty'},fcnName,'PdcchEnable');
    end
    if isfield(evmCfg,'CorrectCoarseFO')
        validateattributes(evmCfg.CorrectCoarseFO,{'logical','double'},{'nonempty'},fcnName,'CorrectCoarseFO');
    end
    if isfield(evmCfg,'CorrectFineFO')
        validateattributes(evmCfg.CorrectFineFO,{'logical','double'},{'nonempty'},fcnName,'CorrectFineFO');
    end
    if isfield(evmCfg,'TimeSyncEnable')
        validateattributes(evmCfg.TimeSyncEnable,{'logical','double'},{'nonempty'},fcnName,'TimeSyncEnable');
    end
    if isfield(evmCfg,'UseWholeGrid')
        validateattributes(evmCfg.UseWholeGrid,{'logical','double'},{'nonempty'},fcnName,'UseWholeGrid');
    end
    if isfield(evmCfg,'IQImbalance')
        validateattributes(evmCfg.IQImbalance,{'logical','double'},{'nonempty'},fcnName,'IQImbalance');
    end
    if isfield(evmCfg,'ExcludeDC')
        validateattributes(evmCfg.ExcludeDC,{'logical','double'},{'nonempty'},fcnName,'ExcludeDC');
    end
    if isfield(evmCfg,'DCOffset')
        validateattributes(evmCfg.DCOffset,{'logical','double'},{'nonempty'},fcnName,'DCOffset');
    end
end

function [waveformResources] = waveformResourcesRepeat(waveformResources,period,repLen)
%   Regenerate PDSCH and PDCCH configuration reference resources based on
%   waveform period and number of waveform repetitions

    % Replicate configuration resources for each waveform repetition
    for repIdx = 1:ceil(repLen/period)-1

        % remSlots is used to repeat resources for slots which
        % are not integer multiples of waveform period 
        remSlots = mod(repLen,period);

        % Loop over all PDSCH and PDCCH configurations
        for cIdx = 1:2
            if cIdx == 1
                str = 'PDSCH';
            else
                str = 'PDCCH';
            end

            % Replicate configuration resources for each PDSCH or PDCCH
            for pIdx = 1:size(waveformResources.(str),2)

                % Obtain allocated slots. Replicate across multiple repetitions
                allocatedSlots = [waveformResources.(str)(pIdx).Resources.NSlot];
                if isempty(allocatedSlots)
                    continue;
                end
                slotRange = period;
                if repIdx == ceil(repLen/period)-1 && remSlots~=0
                    slotRange = remSlots;
                end
                waveformResources.(str)(pIdx).Resources = [waveformResources.(str)(pIdx).Resources ...
                    waveformResources.(str)(pIdx).Resources(allocatedSlots<slotRange)];
                allocatedslotsRepeated = [waveformResources.(str)(pIdx).Resources.NSlot];
                l = size(allocatedSlots,2)+1;
                allocatedslotsRepeated(l:end) = allocatedslotsRepeated(l:end)+ period*repIdx;
                for idx = 1:size(allocatedslotsRepeated,2)
                    waveformResources.(str)(pIdx).Resources(idx).NSlot  = allocatedslotsRepeated(idx);
                end
            end
        end
    end
end